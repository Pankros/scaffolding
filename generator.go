package main

import (
	"fmt"
	"github.com/dave/jennifer/jen"
	"go/types"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var structColPattern = regexp.MustCompile(`col:"([^"]+)"`)

func generate(sourceTypeName string, structType *types.Struct) error {

	// 1. Get the package of the file with go:generate comment
	goPackage := os.Getenv("GOPACKAGE")

	// 2. Start a new file in this package
	f := jen.NewFile(goPackage)

	// 3. Add a package comment, so IDEs detect files as generated
	f.PackageComment("Code generated by generator, DO NOT EDIT.")

	var (
		changeSetFields []jen.Code
	)

	// 4. Iterate over struct fields
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)

		// Generate code for each changeset field
		code := jen.Id(field.Name())
		switch v := field.Type().(type) {
		case *types.Basic:
			code.Op("*").Id(v.String())
		case *types.Named:
			typeName := v.Obj()
			// Qual automatically imports packages
			code.Op("*").Qual(
				typeName.Pkg().Path(),
				typeName.Name(),
			)
		default:
			return fmt.Errorf("struct field type not hanled: %T", v)
		}
		changeSetFields = append(changeSetFields, code)
	}

	// 5. Generate changeset type
	changeSetName := sourceTypeName + "ChangeSet"
	f.Type().Id(changeSetName).Struct(changeSetFields...)

	// 6. Build the target file name
	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "_" + strings.ToLower(sourceTypeName) + "_gen.go"

	// ...

	// 1. Collect code in toMap() block
	var toMapBlock []jen.Code

	// 2. Build "m := make(map[string]interface{})"
	toMapBlock = append(toMapBlock, jen.Id("m").Op(":=").Make(jen.Map(jen.String()).Interface()))

	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		tagValue := structType.Tag(i)

		matches := structColPattern.FindStringSubmatch(tagValue)
		if matches == nil {
			continue
		}
		col := matches[1]

		// 3. Build "if c.Field != nil { m["col"] = *c.Field }"
		code := jen.If(jen.Id("c").Dot(field.Name()).Op("!=").Nil()).Block(
			jen.Id("m").Index(jen.Lit(col)).Op("=").Op("*").Id("c").Dot(field.Name()),
		)
		toMapBlock = append(toMapBlock, code)
	}

	// 4. Build return statement
	toMapBlock = append(toMapBlock, jen.Return(jen.Id("m")))

	// 5. Build toMap method
	f.Func().Params(
		jen.Id("c").Id(changeSetName),
	).Id("toMap").Params().Map(jen.String()).Interface().Block(
		toMapBlock...,
	)

	generateGet(f, structType, sourceTypeName)
	// 7. Write generated file
	return f.Save(targetFilename)
}

func generateGet(f *jen.File, s *types.Struct, sourceTypeName string) {
	query := generateGetQuery(s, sourceTypeName)
	f.Func().Params(
		jen.Id("c").Id(sourceTypeName+"DAO"),
	).Id("Get").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("id").Int(),
	).Call(
		jen.Qual("github.com/mercadolibre/fury_payment-methods-write-v2/src/api/internal/model", sourceTypeName),
		jen.Error(),
	).Block(
		jen.Var().Id("query").Op("=").Lit(query),
		jen.Line(),
		jen.Var().Id("row").Qual("github.com/mercadolibre/fury_payment-methods-write-v2/src/api/internal/model", sourceTypeName),
		jen.Line(),
		jen.Id("err").Op(":=").Qual("p", "db").Dot("Get").Call(jen.Op("&").Id("row"), jen.Id("query"), jen.Id("id")),
		jen.Line(),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Qual("github.com/mercadolibre/fury_payment-methods-write-v2/src/api/internal/model", sourceTypeName).Block(), jen.Id("err")),
		),
		jen.Line(),
		jen.Return(jen.Id("row"), jen.Nil()),
	)
}

func generateGetQuery(s *types.Struct, sourceTypeName string) string {
	return fmt.Sprintf("SELECT %s FROM %s WHERE id = ?", strings.Join(getColumnNames(s), ", "), sourceTypeName)
}

func getColumnNames(s *types.Struct) []string {
	var l []string
	for i := 0; i < s.NumFields(); i++ {
		tagValue := s.Tag(i)
		a := strings.Split(tagValue, ":")[1]
		a = strings.ReplaceAll(a, "\"", "")
		l = append(l, a)
	}
	return l
}
